Fix directory listing display bug in FSP.  Based on upstream commit
06bcc48487676e0ea113ed7ace63798dc0562694

Workaround fsplib ABI dependency on _FILE_OFFSET_BITS.  Based on upstream
commit e517ef22a9c3abab9bf202a76c8f3b4e44c6a773

diff --git a/src/protocol/fsp/fsp.c b/src/protocol/fsp/fsp.c
index 8725a3c..443012a 100644
--- a/src/protocol/fsp/fsp.c
+++ b/src/protocol/fsp/fsp.c
@@ -90,7 +90,8 @@ compare(FSP_RDENTRY *a, FSP_RDENTRY *b)
 static void
 sort_and_display_entries(FSP_DIR *dir)
 {
-	FSP_RDENTRY fentry, *fresult, *table = NULL;
+	FSP_RDENTRY fentry, tmp, *table = NULL;
+	FSP_RDENTRY *fresult = &tmp;
 	int size = 0;
 	int i;
 	unsigned char dircolor[8];
@@ -156,7 +157,9 @@ fsp_directory(FSP_SESSION *ses, struct uri *uri)
 	if (get_opt_bool("protocol.fsp.sort")) {
 		sort_and_display_entries(dir);
 	} else {
-		FSP_RDENTRY fentry, *fresult;
+		FSP_RDENTRY fentry, tmp;
+		FSP_RDENTRY *fresult = &tmp;
+
 		unsigned char dircolor[8];
 
 		if (get_opt_bool("document.browse.links.color_dirs")) {
@@ -200,6 +203,25 @@ do_fsp(struct connection *conn)
 
 	if (!ses)
 		fsp_error("Session initialization failed.");
+
+	/* fsplib 0.8 ABI depends on _FILE_OFFSET_BITS
+	 * https://sourceforge.net/tracker/index.php?func=detail&aid=1674729&group_id=93841&atid=605738
+	 * If ELinks and fsplib are using different values of
+	 * _FILE_OFFSET_BITS, then they get different definitions of
+	 * struct stat, and the st_size stored by fsp_stat is
+	 * typically not the same as the st_size read by ELinks.
+	 * Fortunately, st_mode seems to have the same offset and size
+	 * in both versions of struct stat.
+	 *
+	 * If all the bytes used by the 32-bit st_size are also used
+	 * by the 64-bit st_size, then ELinks may be able to guess
+	 * which ones they are, because the current version 2 of FSP
+	 * supports only 32-bit file sizes in protocol packets.  Begin
+	 * by filling struct stat with 0xAA so that it's easier to
+	 * detect which bytes fsp_stat has left unchanged.  (Only
+	 * sb.st_size really needs to be filled, but filling the rest
+	 * too helps viewing the data with a debugger.)  */
+	memset(&sb, 0xAA, sizeof(sb));
 	if (fsp_stat(ses, data, &sb))
 		fsp_error("File not found.");
 	if (S_ISDIR(sb.st_mode))
@@ -212,16 +234,40 @@ do_fsp(struct connection *conn)
 		if (!file)
 			fsp_error("fsp_fopen error.");
 
+#if SIZEOF_OFF_T >= 8
+		if (sb.st_size < 0 || sb.st_size > 0xFFFFFFFF) {
+			/* Probably a _FILE_OFFSET_BITS mismatch as
+			 * described above.  Try to detect which half
+			 * of st_size is the real size.  This may
+			 * depend on the endianness of the processor
+			 * and on the padding in struct stat.  */
+			if ((sb.st_size & 0xFFFFFFFF00000000ULL) == 0xAAAAAAAA00000000ULL)
+				sb.st_size = sb.st_size & 0xFFFFFFFF;
+			else if ((sb.st_size & 0xFFFFFFFF) == 0xAAAAAAAA)
+				sb.st_size = (sb.st_size >> 32) & 0xFFFFFFFF;
+			else	/* Can't figure it out. */
+				sb.st_size = 1;
+		}
+#endif
+
 		/* Use the default way to find the MIME type, so write an
 		 * 'empty' name, since something needs to be written in order
 		 * to avoid socket errors. */
 		fprintf(stderr, "%c", '\0');
 		fclose(stderr);
 
-		while ((r = fsp_fread(buf, 1, READ_SIZE, file)) > 0)
-			if (safe_write(STDOUT_FILENO, buf, r) <= 0)
-				break;
+		while ((r = fsp_fread(buf, 1, READ_SIZE, file)) > 0) {
+			int off = 0;
+
+			while (r) {
+				int w = safe_write(STDOUT_FILENO, buf + off, r);
 
+				if (w == -1) goto out;
+				off += w;
+				r -= w;
+			}
+		}
+out:
 		fsp_fclose(file);
 		fsp_close_session(ses);
 		exit(0);
